<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Conway Game of Life Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: rgb(180,200,220);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      color: #222;
      font-family: Arial, sans-serif;
    }
    h1 {
      margin: 32px 0 12px 0;
      font-size: 2.5rem;
      font-weight: bold;
      letter-spacing: 0.04em;
    }
    #conway-canvas {
      display: block;
      background: #000;
      box-shadow: 0 4px 24px rgba(0,0,0,0.4);
      border-radius: 8px;
      margin-bottom: 32px;
    }
    .controls {
      margin-bottom: 24px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button, select {
      padding: 8px 18px;
      font-size: 1rem;
      border-radius: 6px;
      border: none;
      background: #222;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover, select:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <h1>Conway's Game of Life</h1>
  <div class="controls">
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <button id="random">Randomize</button>
    <button id="clear">Clear</button>
    <label>Speed:
      <select id="speed">
        <option value="60">Fast</option>
        <option value="30">Medium</option>
        <option value="10">Slow</option>
      </select>
    </label>
  </div>
  <canvas id="conway-canvas" width="720" height="480"></canvas>
  <script>
    const canvas = document.getElementById('conway-canvas');
    const ctx = canvas.getContext('2d');
    let cellSize = 12;
    let cols = 0, rows = 0;
    let grid = [];
    let running = false;
    let interval = null;
    let speed = 60;

    function resizeCanvas() {
      // Make canvas fill the available area below controls
      const controlsHeight = document.querySelector('.controls').offsetHeight;
      const w = window.innerWidth;
      const h = window.innerHeight - controlsHeight;
      canvas.width = w;
      canvas.height = h;
      // Make cell size bigger for smoother animation
      cellSize = Math.max(18, Math.floor(Math.min(w, h) / 32));
      cols = Math.floor(w / cellSize);
      rows = Math.floor(h / cellSize);
      // Always re-init grid if size changed or grid is empty
      if (!Array.isArray(grid) || grid.length !== rows || (grid[0] && grid[0].length !== cols)) {
        grid = Array.from({length: rows}, () => Array.from({length: cols}, () => Math.random() > 0.8 ? 1 : 0));
      }
    }

    window.addEventListener('resize', () => {
      const prevGrid = grid;
      resizeCanvas();
      // Try to preserve previous grid if possible
      if (prevGrid && prevGrid.length && prevGrid[0].length) {
        for (let y = 0; y < Math.min(rows, prevGrid.length); y++) {
          for (let x = 0; x < Math.min(cols, prevGrid[0].length); x++) {
            grid[y][x] = prevGrid[y][x];
          }
        }
      }
      draw();
    });

    // Color for Conway and CA
    function getConwayColor(x, y) {
      // Blueish
      return `rgba(${80 + (x*3)%40},${120 + (y*2)%40},255,0.7)`;
    }
    function getCAColor(x, y) {
      // Orange/Red
      return `rgba(255,${120 + (x*5)%80},${60 + (y*7)%60},0.7)`;
    }

    function draw() {
      // Fill background with bone/cream
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgb(180,200,220)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Prepare to blend
      ctx.globalCompositeOperation = 'multiply';

      // Compute Conway and CA states for color
      let conwayGrid = grid.map(arr => [...arr]);
      let caGrid = grid.map(arr => [...arr]);
      // Conway
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let neighbors = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const ny = y + dy;
              const nx = x + dx;
              if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                neighbors += grid[ny][nx];
              }
            }
          }
          if (grid[y][x] && (neighbors < 2 || neighbors > 3)) conwayGrid[y][x] = 0;
          else if (!grid[y][x] && neighbors === 3) conwayGrid[y][x] = 1;
          else conwayGrid[y][x] = grid[y][x];
        }
      }
      // CA (Rule 30) - top to bottom
      for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
          if (y === 0) {
            caGrid[y][x] = grid[y][x]; // seed row from current grid
          } else {
            const left = x > 0 ? caGrid[y-1][x-1] : 0;
            const center = caGrid[y-1][x];
            const right = x < cols-1 ? caGrid[y-1][x+1] : 0;
            const idx = (left << 2) | (center << 1) | right;
            caGrid[y][x] = rule30[idx];
          }
        }
      }
      // CA (Rule 30) - left to right (new, overlapped)
      let caGridLR = grid.map(arr => [...arr]);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (x === 0) {
            caGridLR[y][x] = grid[y][x]; // seed col from current grid
          } else {
            const up = y > 0 ? caGridLR[y-1][x-1] : 0;
            const left = caGridLR[y][x-1];
            const down = y < rows-1 ? caGridLR[y+1][x-1] : 0;
            // For left-to-right, use left, up-left, down-left as neighbors
            const idx = ((up ? 1 : 0) << 2) | ((left ? 1 : 0) << 1) | (down ? 1 : 0);
            caGridLR[y][x] = rule30[idx];
          }
        }
      }
      // CA (Rule 30) - 2x2 tiny squares, diagonal propagation
      let caGridTiny = grid.map(arr => [...arr]);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (x === 0 || y === 0) {
            caGridTiny[y][x] = grid[y][x]; // seed from current grid
          } else {
            // Diagonal neighbors: up-left, up, left
            const upLeft = caGridTiny[y-1][x-1];
            const up = caGridTiny[y-1][x];
            const left = caGridTiny[y][x-1];
            const idx = ((upLeft ? 1 : 0) << 2) | ((up ? 1 : 0) << 1) | (left ? 1 : 0);
            caGridTiny[y][x] = rule30[idx];
          }
        }
      }
      // Draw Conway cells
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (conwayGrid[y][x]) {
            ctx.fillStyle = getConwayColor(x, y);
            ctx.fillRect(x * cellSize, y * cellSize, cellSize-1, cellSize-1);
          }
        }
      }
      // Draw CA cells (top-bottom)
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (caGrid[y][x]) {
            ctx.fillStyle = getCAColor(x, y);
            ctx.fillRect(x * cellSize, y * cellSize, cellSize-1, cellSize-1);
          }
        }
      }
      // Draw CA cells (left-right, overlapped, with multiply)
      ctx.globalCompositeOperation = 'multiply';
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (caGridLR[y][x]) {
            ctx.fillStyle = 'rgba(80,255,120,0.7)'; // greenish for left-right
            ctx.fillRect(x * cellSize, y * cellSize, cellSize-1, cellSize-1);
          }
        }
      }
      // Draw CA cells (2x2 much tinier squares, overlapped, with multiply)
      ctx.globalCompositeOperation = 'multiply';
      const tiny = Math.max(2, cellSize / 6);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (caGridTiny[y][x]) {
            // Place four much smaller squares in the center of each cell
            const baseX = x * cellSize + cellSize / 2 - tiny;
            const baseY = y * cellSize + cellSize / 2 - tiny;
            ctx.fillStyle = 'rgba(255,200,40,0.6)'; // yellowish for tiny
            ctx.fillRect(baseX, baseY, tiny, tiny);
            ctx.fillRect(baseX + tiny, baseY, tiny, tiny);
            ctx.fillRect(baseX, baseY + tiny, tiny, tiny);
            ctx.fillRect(baseX + tiny, baseY + tiny, tiny, tiny);
          }
        }
      }
      ctx.globalCompositeOperation = 'source-over';
    }

    // Rule 30 lookup table for 1D CA: [left, center, right] as bits
    const rule30 = [0,1,1,1,1,0,0,0];

    function nextGen() {
      const newGrid = grid.map(arr => [...arr]);
      // First, compute Conway's GOL next state
      let conwayGrid = grid.map(arr => [...arr]);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let neighbors = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const ny = y + dy;
              const nx = x + dx;
              if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                neighbors += grid[ny][nx];
              }
            }
          }
          if (grid[y][x] && (neighbors < 2 || neighbors > 3)) conwayGrid[y][x] = 0;
          else if (!grid[y][x] && neighbors === 3) conwayGrid[y][x] = 1;
          else conwayGrid[y][x] = grid[y][x];
        }
      }
      // Now, compute 1D CA (Rule 30) for each row
      let caGrid = grid.map(arr => [...arr]);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (y === 0) {
            caGrid[y][x] = grid[y][x]; // seed row from current grid
          } else {
            const left = x > 0 ? caGrid[y-1][x-1] : 0;
            const center = caGrid[y-1][x];
            const right = x < cols-1 ? caGrid[y-1][x+1] : 0;
            const idx = (left << 2) | (center << 1) | right;
            caGrid[y][x] = rule30[idx];
          }
        }
      }
      // Combine: a cell is alive if either rule would make it alive
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          newGrid[y][x] = conwayGrid[y][x] || caGrid[y][x];
        }
      }
      grid = newGrid;
    }

    function loop() {
      if (!running) return;
      nextGen();
      draw();
      interval = setTimeout(loop, 1000 / speed);
    }

    document.getElementById('start').onclick = () => {
      if (!running) {
        running = true;
        loop();
      }
    };
    document.getElementById('stop').onclick = () => {
      running = false;
      clearTimeout(interval);
    };
    document.getElementById('random').onclick = () => {
      grid = Array.from({length: rows}, () => Array.from({length: cols}, () => Math.random() > 0.8 ? 1 : 0));
      draw();
    };
    document.getElementById('clear').onclick = () => {
      grid = Array.from({length: rows}, () => Array.from({length: cols}, () => 0));
      draw();
    };
    document.getElementById('speed').onchange = (e) => {
      speed = parseInt(e.target.value, 10);
    };

    // Allow click to toggle cells
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);
      if (x >= 0 && x < cols && y >= 0 && y < rows) {
        grid[y][x] = grid[y][x] ? 0 : 1;
        draw();
      }
    });

    resizeCanvas();
    draw();
  </script>
</body>
</html>
